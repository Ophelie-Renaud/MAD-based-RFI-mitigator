/**
 * Copyright or Â© or Copr. IETR/INSA - Rennes (2017 - 2021) :
 *
 * Alexandre Honorat <alexandre.honorat@insa-rennes.fr> (2021)
 *
 * This software is a computer program whose purpose is to help prototyping
 * parallel applications using dataflow formalism.
 *
 * This software is governed by the CeCILL  license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 */

// Generic includes
#include <ap_int.h>
#include <hls_stream.h>


// BEGIN OF AUTOGENERATED PART

// User includes

#include "PreesmAutoDefinedSizes.h"


// END OF AUTOGENERATED PART


// interface_id is here only to specialize the function,
// so that it avoids sharing static attributes between interfaces having same properties
template <typename T, int interface_id, int factor, int rate, int burst_size = 1>
static bool writeOutput(T* out, hls::stream<T> &outStream) {
	static int current_factor = 0;
	static int current_rate = 0;

	if (current_rate < rate && current_factor < factor) {
		if (current_factor == factor - 1) {
			for (int i = 0; i < burst_size; i++) {
				out[current_rate] = outStream.read();
				current_rate++;
			}
		} else {
			for (int i = 0; i < burst_size; i++) {
				outStream.read();
			}
			current_rate += burst_size;
		}

		if (current_rate >= rate && current_factor < factor) {
			current_rate = 0;
			current_factor++;
		}
		return true;
	} else {
		return false;
	}

}



extern "C" {
// BEGIN OF AUTOGENERATED PART

void mem_write_top_rfi_C(
  ap_int<16>* raw_data_im_o_mem,
  hls::stream<ap_int<16>> &raw_data_im_o_stream,
  ap_int<16>* raw_data_real_o_mem,
  hls::stream<ap_int<16>> &raw_data_real_o_stream,
  ap_int<16>* mad_R_o_mem,
  hls::stream<ap_int<16>> &mad_R_o_stream,
  ap_int<16>* raw_data_real_1_o_mem,
  hls::stream<ap_int<16>> &raw_data_real_1_o_stream,
  ap_int<16>* std_R_o_mem,
  hls::stream<ap_int<16>> &std_R_o_stream,
  ap_int<16>* raw_data_im_1_o_mem,
  hls::stream<ap_int<16>> &raw_data_im_1_o_stream,
  ap_int<16>* mad_I_o_mem,
  hls::stream<ap_int<16>> &mad_I_o_stream,
  ap_int<16>* std_I_o_mem,
  hls::stream<ap_int<16>> &std_I_o_stream,
  ap_int<16>* filtered_im_0_o_mem,
  hls::stream<ap_int<16>> &filtered_im_0_o_stream,
  ap_int<16>* filtered_real_0_o_mem,
  hls::stream<ap_int<16>> &filtered_real_0_o_stream,
  ap_int<16>* filtered_im_1_o_mem,
  hls::stream<ap_int<16>> &filtered_im_1_o_stream,
  ap_int<16>* filtered_real_1_o_mem,
  hls::stream<ap_int<16>> &filtered_real_1_o_stream) {
#pragma HLS INTERFACE m_axi offset=slave port=raw_data_im_o_mem name=raw_data_im_o_mem
#pragma HLS INTERFACE axis port=raw_data_im_o_stream name=raw_data_im_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=raw_data_real_o_mem name=raw_data_real_o_mem
#pragma HLS INTERFACE axis port=raw_data_real_o_stream name=raw_data_real_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=mad_R_o_mem name=mad_R_o_mem
#pragma HLS INTERFACE axis port=mad_R_o_stream name=mad_R_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=raw_data_real_1_o_mem name=raw_data_real_1_o_mem
#pragma HLS INTERFACE axis port=raw_data_real_1_o_stream name=raw_data_real_1_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=std_R_o_mem name=std_R_o_mem
#pragma HLS INTERFACE axis port=std_R_o_stream name=std_R_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=raw_data_im_1_o_mem name=raw_data_im_1_o_mem
#pragma HLS INTERFACE axis port=raw_data_im_1_o_stream name=raw_data_im_1_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=mad_I_o_mem name=mad_I_o_mem
#pragma HLS INTERFACE axis port=mad_I_o_stream name=mad_I_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=std_I_o_mem name=std_I_o_mem
#pragma HLS INTERFACE axis port=std_I_o_stream name=std_I_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=filtered_im_0_o_mem name=filtered_im_0_o_mem
#pragma HLS INTERFACE axis port=filtered_im_0_o_stream name=filtered_im_0_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=filtered_real_0_o_mem name=filtered_real_0_o_mem
#pragma HLS INTERFACE axis port=filtered_real_0_o_stream name=filtered_real_0_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=filtered_im_1_o_mem name=filtered_im_1_o_mem
#pragma HLS INTERFACE axis port=filtered_im_1_o_stream name=filtered_im_1_o_stream
#pragma HLS INTERFACE m_axi offset=slave port=filtered_real_1_o_mem name=filtered_real_1_o_mem
#pragma HLS INTERFACE axis port=filtered_real_1_o_stream name=filtered_real_1_o_stream
#pragma HLS INTERFACE s_axilite port=return

  bool shouldContinue = true;
  while (shouldContinue) {
    shouldContinue = false;
    shouldContinue |= writeOutput<ap_int<16>, 0, FACTOR_OF_RAW_DATA_IM_O, RATE_OF_RAW_DATA_IM_O>(raw_data_im_o_mem, raw_data_im_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 1, FACTOR_OF_RAW_DATA_REAL_O, RATE_OF_RAW_DATA_REAL_O>(raw_data_real_o_mem, raw_data_real_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 2, FACTOR_OF_MAD_R_O, RATE_OF_MAD_R_O>(mad_R_o_mem, mad_R_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 3, FACTOR_OF_RAW_DATA_REAL_1_O, RATE_OF_RAW_DATA_REAL_1_O>(raw_data_real_1_o_mem, raw_data_real_1_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 4, FACTOR_OF_STD_R_O, RATE_OF_STD_R_O>(std_R_o_mem, std_R_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 5, FACTOR_OF_RAW_DATA_IM_1_O, RATE_OF_RAW_DATA_IM_1_O>(raw_data_im_1_o_mem, raw_data_im_1_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 6, FACTOR_OF_MAD_I_O, RATE_OF_MAD_I_O>(mad_I_o_mem, mad_I_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 7, FACTOR_OF_STD_I_O, RATE_OF_STD_I_O>(std_I_o_mem, std_I_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 8, FACTOR_OF_FILTERED_IM_0_O, RATE_OF_FILTERED_IM_0_O>(filtered_im_0_o_mem, filtered_im_0_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 9, FACTOR_OF_FILTERED_REAL_0_O, RATE_OF_FILTERED_REAL_0_O>(filtered_real_0_o_mem, filtered_real_0_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 10, FACTOR_OF_FILTERED_IM_1_O, RATE_OF_FILTERED_IM_1_O>(filtered_im_1_o_mem, filtered_im_1_o_stream);
    shouldContinue |= writeOutput<ap_int<16>, 11, FACTOR_OF_FILTERED_REAL_1_O, RATE_OF_FILTERED_REAL_1_O>(filtered_real_1_o_mem, filtered_real_1_o_stream);
  }
}


// END OF AUTOGENERATED PART
}

